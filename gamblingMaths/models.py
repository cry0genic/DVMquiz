import os
import re

from django.conf import settings
from django.contrib.auth.models import User
from django.db import models


class Member(models.Model):

    user = models.OneToOneField(User, unique=True, on_delete=models.CASCADE, related_name='GamblingMathsMember')
    name = models.CharField(max_length=50)
    score = models.IntegerField(default=100)
    
    start_time = models.DateTimeField(null=True)
    uncertainty = models.IntegerField(default=0, blank=True)
    correct_answers = models.IntegerField(default=0, blank=True)
    # As this app will be used for only one quiz.

    questions_generated = models.BooleanField(default=False) #Tells whether or not that set of questions have been generated by the user.
    is_eliminated = models.BooleanField(default=False)
    has_started = models.BooleanField(default=False)
    submitted = models.BooleanField(default=False)
    # Will be set to true if the member has submitted his/her test.
    # Once true, the member cannot access the same test.

    team_member_name = models.CharField(max_length=50, blank=True, default='')
    team_member_email = models.CharField(max_length=80, blank=True, default='')

    def __str__(self):
        return self.name


class Question(models.Model):

    POOL_CHOICES = (
        ('1', 'pool_1'),
        ('2', 'pool_2'),
        ('3', 'pool_3'),
        ('4', 'pool_4'),
        ('5', 'pool_5')
    )

    # Question content --
    questionkey = models.IntegerField(default=0, unique=False)
    content = models.TextField()
    image = models.ImageField(upload_to='ques_img', null=True, blank=True)
    answer = models.CharField(max_length=50, blank=True)

    # Question status --
    attempted_by = models.ManyToManyField(Member, related_name='questions_attempted', blank=True)
    review_by = models.ManyToManyField(Member, related_name='marked_for_review', blank=True)
    not_attempted_by = models.ManyToManyField(Member, related_name='not_attempted', blank=True)
    ar_by = models.ManyToManyField(Member, related_name="ar_questions", blank=True)
    correct_by = models.ManyToManyField(Member, related_name="answered_correctly", blank =True)
    incorrect_by = models.ManyToManyField(Member, related_name="answered_incorrectly", blank=True)

    # Question properties --
    pool = models.CharField(max_length=1, choices=POOL_CHOICES, default = '1')
    score_increment = models.IntegerField(default=10)
    score_decrement = models.IntegerField(default=0)  # For negative marking
    is_image = models.BooleanField(default=False)
    is_mcq = models.BooleanField(default=False)

    def __str__(self):
        return '#{0} Question {1}: {2}'.format(self.pool, self.questionkey+1, self.content)


class MemberQuestion(models.Model): #Which questions are gonna be displayed to a particular member
    pool = models.IntegerField(default=1)
    index = models.IntegerField()
    member = models.ForeignKey(Member, related_name="questions_selected", on_delete=models.CASCADE)
    question = models.ForeignKey(Question, related_name="related_mq_object", on_delete=models.CASCADE)



class Answer(models.Model):
    
    parent_question = models.ForeignKey(
        Question,
        related_name='answers',
        on_delete=models.CASCADE
        )
    content = models.TextField()
    is_correct = models.BooleanField(default=False)
    key = models.IntegerField(default=0)

    def __str__(self):
        return self.content


class Response(models.Model):
    
    member = models.ForeignKey(
        Member,
        related_name="full_response",
        on_delete=models.CASCADE,
        blank=True)

    question = models.ForeignKey(
        Question,
        related_name="ques_response",
        on_delete=models.CASCADE,
        null=True)

    answer_mcq = models.ForeignKey(
        Answer,
        related_name='ans_response',
        on_delete=models.CASCADE,
        null=True)

    answer_text = models.CharField(max_length=250, blank=True)